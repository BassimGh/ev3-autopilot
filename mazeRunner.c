#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_Reflected_Raw)
#pragma config(Motor,  motorA,          leftMotor,     tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          rightMotor,    tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          armMotor,      tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

struct mazePoint {
	bool N;
	bool S;
	bool E;
	bool W;
};

const int lineLength = 5;
const int cols = 7;
const int rows = 9;
const int xOffset = 50;
const int yOffset = 20;

const int startx = 0;
const int starty = 1;
const int endx = 5;
const int endy = 7;
int posx = startx;
int posy = starty;
int xPositions[50];
int yPositions[50];

int steps;

string directions[50];
string moves[50];

mazePoint Maze[cols][rows];

void createMaze() {

	//mazePoint Maze[cols][rows];

	// init maze

	for (int row = 0; row < rows; row ++) {
		for (int col = 0; col < cols; col ++) {
			Maze[col][row].N = false;
			Maze[col][row].S = false;
			Maze[col][row].E = false;
			Maze[col][row].W = false;
		}
	}

	// vertical lines
	for (int row = 0; row < rows; row ++) {
		Maze[5][row].N = true;
		Maze[5][row].S = true;
		//Maze[cols-1][row].N = true;
		//Maze[cols-1][row].S = true;
	}
	Maze[5][8].N = false;
	Maze[5][0].S = false;
	for (int row = 0; row <= 5; row ++) {
		Maze[2][row].N = true;
		Maze[2][row].S = true;
	}
	Maze[2][5].N = false;
	Maze[2][0].S = false;
	for (int row = 1; row <= 4; row ++) {
		Maze[6][row].N = true;
		Maze[6][row].S = true;
	}
	Maze[6][4].N = false;
	Maze[6][1].S = false;

	// horizontal lines
	for (int col = 0; col < cols; col ++) {
		Maze[col][2].E = true;
		Maze[col][2].W = true;
		Maze[col][7].E = true;
		Maze[col][7].W = true;
	}
	Maze[0][2].W = false;
	Maze[6][2].E = false;
	Maze[0][7].W = false;
	Maze[6][7].E = false;

	for (int col = 0; col <= 4; col ++) {
		Maze[col][6].E = true;
		Maze[col][6].W = true;
	}
	Maze[0][6].W = false;
	Maze[4][6].E = false;

	//bottom left corner
	Maze[0][0].N = true;
	Maze[0][1].S = true;
	Maze[0][1].E = true;
	Maze[1][1].W = true;

	Maze[1][1].N = true;
	Maze[1][2].S = true;

	// bottom middle
	Maze[4][0].N = true;
	Maze[4][1].S = true;
	Maze[3][1].E = true;
	Maze[4][1].W = true;

	Maze[3][1].N = true;
	Maze[3][2].S = true;

	// black middle
	Maze[3][2].N = true;
	Maze[3][3].S = true;
	Maze[3][3].E = true;
	Maze[4][3].W = true;

	Maze[4][3].N = true;
	Maze[4][4].S = true;

	Maze[1][4].E = true;
	Maze[2][4].W = true;
	Maze[2][4].E = true;
	Maze[3][4].W = true;

	// Yellow middle
	Maze[1][4].N = true;
	Maze[1][5].S = true;
	Maze[0][5].E = true;
	Maze[1][5].W = true;

	Maze[4][4].N = true;
	Maze[4][5].S = true;
	Maze[3][5].E = true;
	Maze[4][5].W = true;
	Maze[4][5].N = true;
	Maze[4][6].S = true;

	// yellow top left
	Maze[2][7].N = true;
	Maze[2][8].S = true;

	//yellow top right
	Maze[6][6].N = true;
	Maze[6][7].S = true;

	Maze[5][8].E = true;
	Maze[6][8].W = true;
}

void displayMaze() {
	int x = 0;
	int y = 0;

	// draw start position
	drawEllipse(2 * startx * lineLength - lineLength/2 + xOffset,
		2 * starty * lineLength + lineLength/2 + yOffset,
		2 * startx * lineLength + lineLength/2 + xOffset,
		2 * starty * lineLength - lineLength/2 + yOffset);

	// draw target position
	drawEllipse(2 * endx * lineLength - lineLength/2 + xOffset,
		2 * endy * lineLength + lineLength/2 + yOffset,
		2 * endx * lineLength + lineLength/2 + xOffset,
		2 * endy * lineLength - lineLength/2 + yOffset);

	for (int row = 0; row < rows; row++) {
		for (int col = 0; col < cols; col++) {
			x = col * lineLength * 2 + xOffset;
			y = row * lineLength * 2 + yOffset;
			if (Maze[col][row].S == 1) drawLine(x, y, x, y - lineLength);
			if (Maze[col][row].N == 1) drawLine(x, y, x, y + lineLength);
			if (Maze[col][row].W == 1) drawLine(x, y, x - lineLength, y);
			if (Maze[col][row].E == 1) drawLine(x, y, x + lineLength, y);
		}
	}
}


struct intersection {
	int i;
	int x;
	int y;
	bool N;
	bool S;
	bool E;
	bool W;
}

void solveMaze() {
	bool solved = false;
	int pathCount;
	mazePoint path;

	intersection intersection[20];
	int intersections = 0;

	int i = 0;  // directions index
	int h = 0;

	posx = startx;
	posy = starty;

	xPositions[i] = posx;
	yPositions[i] = posy;

	while (!solved){
		//delay(500);

		pathCount = 0;

		path.N = false;
		path.S = false;
		path.E = false;
		path.W = false;

		displayCenteredTextLine(14, "%d",posx);
		displayCenteredTextLine(15, "%d", posy);

		if (posx == endx && posy == endy) {
			displayBigTextLine(1,"SOLVED");
			delay(1000);
			solved = true;
			break;
		}
		if (i > 0) {
			if (Maze[posx][posy].N && directions[i-1] != "S") {
				pathCount ++;
				path.N = true;
			}
			if (Maze[posx][posy].S && directions[i-1] != "N") {
				pathCount ++;
				path.S = true;
			}
			if (Maze[posx][posy].E && directions[i-1] != "W") {
				pathCount ++;
				path.E = true;
			}
			if (Maze[posx][posy].W && directions[i-1] != "E") {
				pathCount ++;
				path.W = true;
			}
		}
		else {
			if (Maze[posx][posy].N) {
				pathCount ++;
				path.N = true;
			}
			if (Maze[posx][posy].S) {
				pathCount ++;
				path.S = true;
			}
			if (Maze[posx][posy].E) {
				pathCount ++;
				path.E = true;
			}
			if (Maze[posx][posy].W) {
				pathCount ++;
				path.W = true;
			}
		}
		// dead end
		if (pathCount < 1) {
			i = intersection[intersections - 1].i;
			posx = intersection[intersections - 1].x;
			posy = intersection[intersections - 1].y;
		}
		// one path
		else if (pathCount == 1) {
			if (path.N) {
				posy ++;
				directions[i] = "N";
			}
			else if (path.S) {
				posy --;
				directions[i] = "S";
			}
			else if (path.E) {
				posx ++;
				directions[i] = "E";
			}
			else if (path.W) {
				posx --;
				directions[i] = "W";
			}
			i++;
		}
		// intersectino
		else if (pathCount > 1) {
			// check if intersection is new
			bool repeated = false;
			for (int j = 0; j < intersections; j++) {
				if (intersection[j].i == i) {
					repeated = true;
				}
			}
			if (!repeated) {
				intersections ++;
				intersection[intersections - 1].i = i;
				intersection[intersections - 1].x = posx;
				intersection[intersections - 1].y = posy;
				intersection[intersections - 1].N = false;
				intersection[intersections - 1].S = false;
				intersection[intersections - 1].E = false;
				intersection[intersections - 1].W = false;

				if (path.N) {
					intersection[intersections - 1].N = true;
				}
				if (path.S) {
					intersection[intersections - 1].S = true;
				}
				if (path.E) {
					intersection[intersections - 1].E = true;
				}
				if (path.W) {
					intersection[intersections - 1].W = true;
				}
			}

			if (intersection[intersections - 1].N) {
				intersection[intersections - 1].N = false;
				posy ++;
				directions[i] = "N";
				i++;
			}
			else if (intersection[intersections - 1].S && intersections > 0) {
				intersection[intersections - 1].S = false;
				posy --;
				directions[i] = "S";
				i++;
			}
			else if (intersection[intersections - 1].E && intersections > 0) {
				intersection[intersections - 1].E = false;
				posx ++;
				directions[i] = "E";
				i++;
			}
			else if (intersection[intersections - 1].W && intersections > 0) {
				intersection[intersections - 1].W = false;
				posx --;
				directions[i] = "W";
				i++;
			}
			else {
				//  dead end
				intersections --;
				i = intersection[intersections - 1].i;
				posx = intersection[intersections - 1].x;
				posy = intersection[intersections - 1].y;
			}
		}

		xPositions[i] = posx;
		yPositions[i] = posy;
		h++;
	}
	// saves number of steps to get to shortest path
	steps = i;
}

void lineTrack(bool leftLine) {
	// if line on the left
	if (leftLine) {
		//	black lines area
		if (posy <= 4) {
			if (getColorReflected(colorSensor) < 15)  {
				setMotorSpeed(leftMotor, -10);
				setMotorSpeed(rightMotor, 0);
			}
			else {
				setMotorSpeed(leftMotor, 0);
				setMotorSpeed(rightMotor, -10);
			}
		}
		//  yellow lines area
		else {
			if (getColorReflected(colorSensor) > 40)  {
				setMotorSpeed(leftMotor, -10);
				setMotorSpeed(rightMotor, 0);
			}
			else {
				setMotorSpeed(leftMotor, 0);
				setMotorSpeed(rightMotor, -10);
			}
		}
	}
	// if line on the right
	else {
		//	black lines area
		if (posy <= 4) {
			if (getColorReflected(colorSensor) < 15)  {
				setMotorSpeed(leftMotor, 0);
				setMotorSpeed(rightMotor, -10);
			}
			else {
				setMotorSpeed(leftMotor, -10);
				setMotorSpeed(rightMotor, 0);
			}
		}
		//	yellow lines area
		else {
			if (getColorReflected(colorSensor) > 40)  {
				setMotorSpeed(leftMotor, 0);
				setMotorSpeed(rightMotor, -10);
			}
			else {
				setMotorSpeed(leftMotor, -10);
				setMotorSpeed(rightMotor, 0);
			}
		}
	}
}

bool leftScan (bool turn) {
	bool leftLine = false;
	int encoderTarget = 100;
	while (getMotorEncoder(armMotor) < encoderTarget) {
		setMotorSpeed(armMotor, 5);
		if (turn) {
			if (posy <= 4) {
				if (getColorReflected(colorSensor) < 15 && getMotorEncoder(armMotor) > 45) {
					leftLine = true;
				}
			}
			else {
				if (getColorReflected(colorSensor) > 40 && getMotorEncoder(armMotor) > 45) {
					leftLine = true;
				}
			}
		}
		else {
			if (posy <= 4) {
				if (getColorReflected(colorSensor) < 15) {
					leftLine = true;
				}
			}
			else {
				if (getColorReflected(colorSensor) > 40) {
					leftLine = true;
				}
			}
		}
	}
	encoderTarget = 0;
	while (getMotorEncoder(armMotor) > encoderTarget) {
		setMotorSpeed(armMotor, -5);
		if (turn) {
			if (posy <= 4) {
				if (getColorReflected(colorSensor) < 15 && getMotorEncoder(armMotor) > 45) {
					leftLine = true;
				}
			}
			else {
				if (getColorReflected(colorSensor) > 40 && getMotorEncoder(armMotor) > 45) {
					leftLine = true;
				}
			}
		}
		else {
			if (posy <= 4) {
				if (getColorReflected(colorSensor) < 15) {
					leftLine = true;
				}
			}
			else {
				if (getColorReflected(colorSensor) > 40) {
					leftLine = true;
				}
			}
		}
	}
	setMotorSpeed(armMotor, 0);
	return leftLine;
}

bool rightScan (bool turn) {
	bool rightLine = false;
	int encoderTarget = -100;
	while (getMotorEncoder(armMotor) > encoderTarget) {
		setMotorSpeed(armMotor, -5);
		if (turn) {
			if (posy <= 4) {
				if (getColorReflected(colorSensor) < 15 && getMotorEncoder(armMotor) < -45) {
					rightLine = true;
				}
			}
			else {
				if (getColorReflected(colorSensor) > 40 && getMotorEncoder(armMotor) < -45) {
					rightLine = true;
				}
			}
		}
		else {
			if (posy <= 4) {
				if (getColorReflected(colorSensor) < 15) {
					rightLine = true;
				}
			}
			else {
				if (getColorReflected(colorSensor) > 40) {
					rightLine = true;
				}
			}
		}
	}
	encoderTarget = 0;
	while (getMotorEncoder(armMotor) < encoderTarget) {
		setMotorSpeed(armMotor, 5);
		if (turn) {
			if (posy <= 4) {
				if (getColorReflected(colorSensor) < 15 && getMotorEncoder(armMotor) < -45) {
					rightLine = true;
				}
			}
			else {
				if (getColorReflected(colorSensor) > 40 && getMotorEncoder(armMotor) < -45) {
					rightLine = true;
				}
			}
		}
		else {
			if (posy <= 4) {
				if (getColorReflected(colorSensor) < 15) {
					rightLine = true;
				}
			}
			else {
				if (getColorReflected(colorSensor) > 40) {
					rightLine = true;
				}
			}
		}
	}
	setMotorSpeed(armMotor, 0);
	return rightLine;
}

// Line on the left: 0
// Line on the right: 1
// Line on the both: 2
// no line: -1
bool findLine(bool turn) {
	bool leftLine = false;
	bool rightLine = false;
	if (leftScan(turn)) {
		leftLine = true;
	}
	if (rightScan(turn)) {
		rightLine = true;
	}
	if (leftLine && !rightLine) {
		return true;
	}
	else if (!leftLine && rightLine) {
		return false;
	}
	else {
		return false;
	}
}

void leftTurn() {
	int change = 150;
	int encoderTarget = getMotorEncoder(rightMotor) - change;
	while (getMotorEncoder(rightMotor) > encoderTarget) {
		setMotorSpeed(leftMotor, -10);
		setMotorSpeed(rightMotor, -10);
	}
	setMotorSpeed(leftMotor, 0);
	setMotorSpeed(rightMotor, 0);
	change = 350;
	encoderTarget = getMotorEncoder(rightMotor) - change;
	while (getMotorEncoder(rightMotor) > encoderTarget) {
		setMotorSpeed(rightMotor, -10);
	}
	setMotorSpeed(rightMotor, 0);

	change = 250;
	encoderTarget = getMotorEncoder(rightMotor) + change;
	while (getMotorEncoder(rightMotor) < encoderTarget) {
		setMotorSpeed(leftMotor, 10);
		setMotorSpeed(rightMotor, 10);
	}
	setMotorSpeed(leftMotor, 0);
	setMotorSpeed(rightMotor, 0);
}

void rightTurn() {
	int change = 150;
	int encoderTarget = getMotorEncoder(leftMotor) - change;
	while (getMotorEncoder(leftMotor) > encoderTarget) {
		setMotorSpeed(leftMotor, -10);
		setMotorSpeed(rightMotor, -10);
	}
	setMotorSpeed(leftMotor, 0);
	setMotorSpeed(rightMotor, 0);
	change = 350;
	encoderTarget = getMotorEncoder(leftMotor) - change;
	while (getMotorEncoder(leftMotor) > encoderTarget) {
		setMotorSpeed(leftMotor, -10);
	}
	setMotorSpeed(leftMotor, 0);

	change = 250;
	encoderTarget = getMotorEncoder(rightMotor) + change;
	while (getMotorEncoder(rightMotor) < encoderTarget) {
		setMotorSpeed(leftMotor, 10);
		setMotorSpeed(rightMotor, 10);
	}
	setMotorSpeed(leftMotor, 0);
	setMotorSpeed(rightMotor, 0);
}

// This function is responsible for every robot movement
void move(int direction) {
	bool left = findLine(false);
	//bool left = true;
	int change = 600;
	int thresh = 300;
	int encoderTarget;
	bool foundLine = false;

	while (!foundLine) {
		lineTrack(left);
		if (posy <= 4) {
			if (getColorReflected(colorSensor) < 15) {
				foundLine = true;
			}
		}
		else {
			if (getColorReflected(colorSensor) > 40) {
				foundLine = true;
			}
		}
	}

	encoderTarget = getMotorEncoder(rightMotor) - change;

	while (getMotorEncoder(rightMotor) > encoderTarget - thresh) {
		lineTrack(left);
		if (abs(getMotorEncoder(rightMotor) - encoderTarget) < thresh) {
			setMotorSpeed(leftMotor, 0);
			setMotorSpeed(rightMotor, 0);
			break;
		}
	}

	while (getMotorEncoder(rightMotor) > encoderTarget) {
		setMotorSpeed(leftMotor, -10);
		setMotorSpeed(rightMotor, -10);
		if (abs(getMotorEncoder(rightMotor) - encoderTarget) < thresh) {
			setMotorSpeed(leftMotor, 0);
			setMotorSpeed(rightMotor, 0);
			if (direction == -1) {
				if(leftScan(true)) break;
			}
			else if (direction == 1) {
				if(rightScan(true)) break;
			}
			thresh -= 150;
		}
	}

	setMotorSpeed(leftMotor, 0);
	setMotorSpeed(rightMotor, 0);

	if (direction == -1) {
		leftTurn();
	}
	else if (direction == 1) {
		rightTurn();
	}
}
// transform N,E,S,W directions to left forward and right directions based on robot orientation
void getDirections() {
	posx = startx;
	posy = starty;
	string orientation;
	//moves[0] = "F";

	orientation = directions[0];

	for (int i = 1; i < steps; i++) {
		// set moves
		if (directions[i] == orientation) {
			moves[i] = "F";
		}
		else if (orientation == "N" && directions[i] == "W" ||
				orientation == "E" && directions[i] == "N" ||
				orientation == "S" && directions[i] == "E" ||
				orientation == "W" && directions[i] == "S" ) {
			moves[i] = "L";
			if (orientation == "N") {
				orientation = "W";
			}
			else if (orientation == "E") {
				orientation = "N";
			}
			else if (orientation == "S") {
				orientation = "E";
			}
			else if (orientation == "W") {
				orientation = "S";
			}
		}
		else if (orientation == "N" && directions[i] == "E" ||
				orientation == "E" && directions[i] == "S" ||
				orientation == "S" && directions[i] == "W" ||
				orientation == "W" && directions[i] == "N" ) {
			moves[i] = "R";
			if (orientation == "N") {
				orientation = "E";
			}
			else if (orientation == "E") {
				orientation = "S";
			}
			else if (orientation == "S") {
				orientation = "W";
			}
			else if (orientation == "W") {
				orientation = "N";
			}
		}
	}
}
void moveRobot() {
	posx = startx;
	posy = starty;
	for (int i = 0; i < steps; i++) {
		if (i > 0) {
			if (yPositions[i-1] <= 4) {
				posx = xPositions[i];
				posy = yPositions[i];
			}
		}
		else if (starty <= 4) {
			posx = xPositions[i];
			posy = yPositions[i];
		}

		if (moves[i] == "F") {
			//displayCenteredTextLine(1,"straight");
			//delay(1000);
			//displayCenteredTextLine(1," ");
			//delay(200);

			move(0);
		}
		else if(moves[i] == "R") {
			//displayCenteredTextLine(1,"straight right");
			//delay(1000);
			//displayCenteredTextLine(1," ");
			//delay(200);

			move(1);
		}
		else if(moves[i] == "L") {
			//displayCenteredTextLine(1,"straight left");
			//delay(1000);
			//displayCenteredTextLine(1," ");
			//delay(200);

			move(-1);
		}
		if (i > 0) {
			if (yPositions[i-1] > 4) {
				posx = xPositions[i];
				posy = yPositions[i];
			}
		}
		else if (starty > 4) {
			posx = xPositions[i];
			posy = yPositions[i];
		}

		eraseDisplay();
		displayMaze();

		if (directions[i] == "N") {
			displayStringAt(2 * posx * lineLength + xOffset  - lineLength/2 , 2 * posy * lineLength + yOffset + lineLength/2,"^");
		}
		else if (directions[i] == "E") {
			displayStringAt(2 * posx * lineLength + xOffset  - lineLength/2 , 2 * posy * lineLength + yOffset + lineLength/2,">");
		}
		else if (directions[i] == "S") {
			displayStringAt(2 * posx * lineLength + xOffset  - lineLength/2 , 2 * posy * lineLength + yOffset + lineLength/2,"V");
		}
		else if (directions[i] == "W") {
			displayStringAt(2 * posx * lineLength + xOffset  - lineLength/2 , 2 * posy * lineLength + yOffset + lineLength/2,"<");
		}

		displayCenteredTextLine(14, "%d",posx);
		displayCenteredTextLine(15, "%d", posy);
	}

	// Last move

	move(0);
	eraseDisplay();
	displayMaze();

	if (directions[steps-1] == "N") {
		posy++;
		displayStringAt(2 * posx * lineLength + xOffset  - lineLength/2 , 2 * posy * lineLength + yOffset + lineLength/2,"^");
	}
	else if (directions[steps-1] == "E") {
		posx++;
		displayStringAt(2 * posx * lineLength + xOffset  - lineLength/2 , 2 * posy * lineLength + yOffset + lineLength/2,">");
	}
	else if (directions[steps-1] == "S") {
		posy--;
		displayStringAt(2 * posx * lineLength + xOffset  - lineLength/2 , 2 * posy * lineLength + yOffset + lineLength/2,"V");
	}
	else if (directions[steps-1] == "W") {
		posx--;
		displayStringAt(2 * posx * lineLength + xOffset  - lineLength/2 , 2 * posy * lineLength + yOffset + lineLength/2,"<");
	}

	// final move
	delay(1000);
	displayCenteredTextLine(14, "%d",posx);
	displayCenteredTextLine(15, "%d", posy);

}

void startSound() {
	playTone(  880,    7); wait1Msec(  100);  // Note(D, Duration(32th))
	playTone(  880,    7); wait1Msec(  100);  // Note(D, Duration(32th))
	playTone(  880,    7); wait1Msec(  100);  // Note(D, Duration(32th))
}

void endSound() {
	playTone( 1109,   14); wait1Msec( 600);  // Note(F#, Duration(16th))
	playTone( 1109,   14); wait1Msec( 600);  // Note(F#, Duration(16th))
	playTone( 1109,   14); wait1Msec( 600);  // Note(F#, Duration(16th))
}

task main()
{
	createMaze();
	solveMaze();
	displayMaze();
	getDirections();
	startSound();
	moveRobot();
	endSound();
}
